<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd" >
<mapper namespace="kr.or.ddit.member.dao.IMemberDAO">
	<sql id="searchFrag"> <!-- 중복되는 코드를 넣는다. -->
	<!-- ${searchVO.searchType} Like '%' || #{searchVO.searchWord} || '%' ===> sql injection에 취약해서 대신 아래를 사용한다. -->
	<where> <!-- 아래 조건절을 하나이상 만족하면 이 키워드 사용 -->
			<if test="searchVO!=null">
				<if test="@org.apache.commons.lang3.StringUtils@isNotBlank(searchVO.searchWord)">
				<!-- OGNL언어 @class@method(args).  검색키워드가 있으면..-->
					<choose> 
						<when test="'id'.equals(searchVO.searchType)">
							MEM_ID Like '%' || #{searchVO.searchWord} || '%'
						</when>
						<when test="'name'.equals(searchVO.searchType)">
							MEM_NAME Like '%' || #{searchVO.searchWord} || '%'
						</when>
						<when test="'address'.equals(searchVO.searchType)">
							MEM_ADD1 Like '%' || #{searchVO.searchWord} || '%'
						</when>
						<otherwise>
							MEM_ID Like '%' || #{searchVO.searchWord} || '%'
							OR MEM_NAME Like '%' || #{searchVO.searchWord} || '%'
							OR MEM_ADD1 Like '%' || #{searchVO.searchWord} || '%'
						</otherwise>
					</choose>
				</if>
			</if>
			</where>
	
	</sql>
	
	
	<select id="selectMemberCount" resultType="int">
		SELECT COUNT(*) 
		FROM MEMBER
		<include refid="searchFrag"></include>
		
	</select>
	
	<select id="selectMemberList"
		resultType="memberVO"
		parameterType="PagingVO">
		SELECT B.*
		FROM
		(SELECT ROWNUM RN, A.*
			FROM
			(SELECT MEM_ID, MEM_BIR, MEM_NAME, MEM_HP,
					MEM_MAIL, MEM_ADD1, MEM_MILEAGE
			FROM MEMBER
			<include refid="searchFrag"></include>
			ORDER BY MEM_BIR DESC) A)B
    		WHERE RN BETWEEN #{startRow} AND #{endRow}
	</select>


	<resultMap type="memberVO" id="memberMap" autoMapping="true"> 
		<id property="mem_id" column="MEM_ID"/> <!-- memberVO 여러개 생성 방지. 같은 객체인것을 식별. 중복제거 후 하나의 객체로 만듦 -->
		<collection property="prodList" javaType="java.util.List"
			ofType="prodVO" autoMapping="true"> <!-- 1:n관계일때는 collection, 1:1은 association -->
		</collection>
	</resultMap>	
	<!-- public MemberVO selectMember(String mem_id); -->
	<select id="selectMember" resultMap="memberMap"
		parameterType="java.lang.String">
		SELECT
			MEM_ID, MEM_PASS, MEM_NAME,
			MEM_REGNO1, MEM_REGNO2, TO_CHAR(MEM_BIR, 'YYYY-MM-DD') MEM_BIR,
			MEM_ZIP, MEM_ADD1, MEM_ADD2,
			MEM_HOMETEL, MEM_COMTEL, MEM_HP,
			MEM_MAIL, MEM_JOB, MEM_LIKE,
			MEM_MEMORIAL, TO_CHAR(MEM_MEMORIALDAY, 'YYYY-MM-DD') MEM_MEMORIALDAY, MEM_MILEAGE,
			MEM_DELETE, MEM_IMG
			, PROD_NAME, PROD_COST, PROD_PRICE, PROD_MILEAGE
			, LPROD_NM
			, BUYER_NAME
		FROM MEMBER LEFT OUTER JOIN CART ON (MEM_ID = CART_MEMBER) 
            LEFT OUTER JOIN PROD ON (CART_PROD =PROD_ID)
            LEFT OUTER JOIN LPROD ON (PROD_LGU = LPROD_GU)
            LEFT OUTER JOIN BUYER ON (PROD_BUYER = BUYER_ID)
		WHERE MEM_ID = #{noname}
	</select>
	<update id="updateMember" parameterType="memberVO">

		UPDATE MEMBER
		SET                      <!-- jdbcType=VARCHAR null데이터를 type에 맞게 넣어준다. -->
		  <!-- javabean규약에 의해 만들면 내부적으로 
			member.getMem_name()로 돌아간다.(private이기 때문에) -->
		MEM_ZIP = #{mem_zip,jdbcType=VARCHAR} ,
		MEM_ADD1 = #{mem_add1,jdbcType=VARCHAR} ,
		MEM_ADD2 = #{mem_add2,jdbcType=VARCHAR} ,
		MEM_HOMETEL = #{mem_hometel,jdbcType=VARCHAR} ,
		MEM_COMTEL = #{mem_comtel,jdbcType=VARCHAR} ,
		MEM_HP = #{mem_hp,jdbcType=VARCHAR} ,
		MEM_MAIL = #{mem_mail,jdbcType=VARCHAR} ,
		MEM_JOB = #{mem_job,jdbcType=VARCHAR} ,
		MEM_LIKE = #{mem_like,jdbcType=VARCHAR} ,
		MEM_MEMORIAL = #{mem_memorial,jdbcType=VARCHAR} ,
		MEM_MEMORIALDAY = TO_DATE(#{mem_memorialday,jdbcType=DATE}, 'YYYY-MM-DD')
		<if test="mem_img!=null">
		,MEM_IMG = #{mem_img}
		</if>
		WHERE MEM_ID = #{mem_id}
	</update>
	<delete id="deleteMember" parameterType="java.lang.String">
		UPDATE MEMBER SET
		MEM_DELETE = 'Y' WHERE MEM_ID = #{id}
	</delete>

	<update id="insertMember" parameterType="memberVO">
		INSERT INTO member(
		MEM_ID,
		MEM_PASS,
		MEM_NAME,
		MEM_REGNO1,
		MEM_REGNO2,
		MEM_BIR,
		MEM_ZIP,
		MEM_ADD1,
		MEM_ADD2,
		MEM_HOMETEL,
		MEM_COMTEL,
		MEM_HP,
		MEM_MAIL,
		MEM_JOB,
		MEM_LIKE,
		MEM_MEMORIAL,
		MEM_MEMORIALDAY, MEM_MILEAGE, 
			MEM_IMG)

		VALUES( #{mem_id,jdbcType=VARCHAR} , #{mem_pass,jdbcType=VARCHAR} ,
		#{mem_name,jdbcType=VARCHAR} ,
		#{mem_regno1,jdbcType=VARCHAR} ,
		#{mem_regno2,jdbcType=VARCHAR} ,
		TO_DATE(#{mem_bir,jdbcType=DATE} , 'YYYY-MM-DD'),
		#{mem_zip,jdbcType=VARCHAR} ,
		#{mem_add1,jdbcType=VARCHAR} ,
		#{mem_add2,jdbcType=VARCHAR} ,
		#{mem_hometel,jdbcType=VARCHAR} ,
		#{mem_comtel,jdbcType=VARCHAR} ,
		#{mem_hp,jdbcType=VARCHAR} ,
		#{mem_mail,jdbcType=VARCHAR} ,
		#{mem_job,jdbcType=VARCHAR} ,
		#{mem_like,jdbcType=VARCHAR} ,
		#{mem_memorial,jdbcType=VARCHAR} ,
		TO_DATE(#{mem_memorialday,jdbcType=DATE}, 'YYYY-MM-DD') ,
		3000, #{mem_img,jdbcType=BLOB} )

	</update>
</mapper>
